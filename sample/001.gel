/* DO NOT READ THIS FILE */

set ITS_A_COMMENTARY_DID_U_KNO = true
// i'm trying to conclude a preferred grammar for a new version of this trash language.
// KEL (2013-2020 version) is not a poorly designed language.
// but it's more like I'm pretending this thing will be more interesting
// if I specify it to be a complex impossible-to-parse language trash.
// Currently, it cannot do anything. even simple interpreting is not possible.

// and yes. this is a comment
#  this is also a comment (but unlike slashes, it can do more than just commenting. see below (TODO))
#  so, I will use # for general commentating in this sample code.

# first, let's I told you that KEL (Kongfa's Executable Lines) is a language that is designed to be trash.
# no no
# i mean, it's a toy language !
# it's a toy language that is designed to be trash.
# k enough. it's my dream language. it was 2013 when i'm doing jack shit and thinking about,
# what if I owned some programming language.
# As when I was young then, I randomly write some omega incredible syntaxes into white A4 paper during class time
# and hope someday it would be executable on some machine.
# damn it. im lazy to tell you the story. just read the code below.

# welcumm to 2565 (2022). i'm way smarter than before (maybe)
# i wrote this (small) specification. to remind me of these things

# GEL = gongpha's extensible language (or executable lines like original KEL)
# the name was inspired by XML actually. but it's not a markup language. dud
# i avoid using 'X' in the name because... i don't know. i just don't like it.
# it's like, HI GUYS. TODAY, I WILL GUIDE YOU TO LEARN HOW TO WRITE GXL (gongpha's eXtensible Language) -3-
# that is pronounced like "GEE-ECKS-AEWL". i hate it
# so call it GEL.

# i will keep using simple english. im not a native english speaker. im suck at it. fucc an education system

# -- HOW THE LANGUAGE SEES THE IMMUTABLES -- #
# Tokenizer :
2									# u* | i* | f*
0x99246862							# ^^^ (same as above)
0b00010001							# ^^^
10_000_000							# ^^^
"500 baht"							# string | u*[]
'500 baht'							# ^^^
"C"									# ^^^
'C'									# u*
0.12345678							# f*
.123456789							# ^^^


# !!! ADVANCED !!! #
`{5} baht`							# tstring (template literal)
									# if assigned to string-based type. it will be evaluated.
/("18"*3)/							# literal comprehension. just evaluate a expression as string.
									# then convert to a source code token.
									# evaluated as 181818
/("\"esan\""*4)/					# ^^^. "esanesanesanesan"
/(getMyLiteral())/					# ^^^. uses as function (the function must returns "string" !)
/("9"*50)/							# 999999999999999... (50x)
									# well, while it cannot fit in any of the above built-in types,
									# it will be marked as a "int" type. an arbitrary-precision integer.
?2p12c910?							# stablelink2017 (dont ask me about this)

# (lets me dig another specification in my old notebook . . .)

# -- SET STATEMENTS -- #
set a (i32)							# classic static typing (2016) = GARBAGE VALUE
set b (i32 | f32)					# mini union type (like ts) = GARBAGE VALUE
set c (i32[10])						# static array (*[u*]) = GARBAGE VALUE
set d (Array<i32>)					# dynamic array = an empty Array<...> object
# NOTE : set cannot be an expression !

# -- typing -- #
set P = 0							# typed as u* | i* | f* (u8 | u16 | u32 | u64 | i8 | ...)
P = "eiei"							# error. cannot assign a string to u* | i* | f*
set M								# yeah, you can do this. it's a dynamic type. AND m is undef (see below for details)
M = 100								# yes
M = "555+"							# yes. yes
M = null							# YES YES YES
M = undef							# oh wait, assigning undef is not allowed. error.
									# k, let's I tell you what undef is.
									# undef is a special type. it's like null, but it's not a value.
									# unlike js's undefined, it used to represent a variable that is not assigned yet.
									# and you can compare with it. To check if a variable is assigned or not.
M != undef							# this expression is false.


# !!! ADVANCED !!! #
set Q								# whatever (Q = undef)
Q = null							# null.
Q = "korsetyorsudpor"				# ok
Q <+- i32							# Add static type. now, Q can have i32 only (what kind of operator is this ???)
									# and yeah, error. a string is already assigned. cannot add static type.
									# set to a new type or null first.
Q = 0								# LIKE THIS
Q <+- i32							# now it's ok.
Q = 2								# YES
Q <+- string						# yes, string too
Q = "ISAN"							# YES YES
Q = 555								# YES YES YES
Q = 1.2								# YE- . . . wait, NO ! f* is not allowed.
set R 

# !!! ADVANCED !!! #
set (A (i32), B (i32), C (i32))		# multiple declarations

# -- BLOCK -- #
aaa :								# python style mutiline (required indentation)
	bbb
aaa : bbb							# inline. equivalent to above
									# dont use these when you're trying to write a whole code in a single line.
									# semicolons are used for separating statements. not exit a block.
aaa : bbb; ccc						# expecting ccc is outside the block ? NO it's inside a block

aaa {								# C style (no indentation)
	bbb
	ccc
}
aaa { bbb } ccc						# ccc is a statement after the block
aaa { bbb; ccc }					# ccc is now inside the block. NOT equivalent to above

aaa {								# this code should work ^_^
	bbb :
		ccc
		ddd {
			eee : fff
		}
	ccc { ggg }
	hhh : iii; jjj { kkk : lll }
}